---
标题：Tuyin IR语言参考手册
描述：对 中间码 使用有用的资料和其他资源。
---
 # Tuyin IR语言参考手册

Tuyin IR是一个基于SSA（静态单赋值）的`graph`表示，在`v1.0`中它不再面向于汇编层面，而是近似于`MSIL`的文法那样对策中间表示，在保证并行优化的前提下，提供了类型安全，低级别操作，灵活性的同时保证了人类可读性。且Tuyin IR它也是在Tuyin编译策略的各个阶段中使用的通用代码表示。

Tuyin IR的代码表示形式被设计为使用三种不同的格式：

1. 表示为在内存中编译器中间语言。
2. 表示为在磁盘上的`bitcode`（适合于编译器的快速加载和本地化储存）。
3. 表示为人类可读的中间语言，Tuyin为编译器的高效转换和分析提供了强大的中间语言，同时提供一个自然的方法来调试和可视化的转换。Tuyin的这三种不同形式的代码表示的都是等价的。本文档描述了人类可读的代表性和符号。

Tuyin IR的目标是实现轻量和低级别同时是有表现力的，隐式类型化，可扩展。它的目标是成为一个`逻辑`与`图形`互相理解且转化的工具，使用`graph`来表示逻辑中的每一个阶段。Tuyin通过提供隐式类型信息和自动扩展数据长度，从而达到优化的目的：例如，通过引用关系我们可以得到函数内各个命名变量的使用规则，并在取得类型时自动为其填充长度。

借由强大的`多层graph`概念，Tuyin可以做到将任意人类可读逻辑分支优化合并，例如下列`origin`总是会被优化为`shortest`:　

```csharp
// origin
((START MIDDLE) | (START MIDDLE START)) START

// shortest
START MIDDLE START START?
```

Tuyin 在处理`多层graph`时内部进行了大量的优化，保证原意不变的前提下对任意递归视图进行最短等效路径的查找，而该`多层graph`会应用在诸如编译前端中的parser、编译后端中的优化器和AI的建模等部分。

## <span id="token_class_">标识符

Tuyin IR 标识符有两种基本类型：

- 全局标识符（函数，全局变量）以`@`字符开头。
- 本地标识符（寄存器名称，类型）以`%`字符开头。

标识符有三种不同的格式，分别用于不同的目的：

1. 命名值表示为带有前缀的字符串。例如%foo，@DivisionByZero，%a.really.long.identifier。可以表示为正则表达式`[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*`。名称中需要其他字符的标识符可以用引号括起来。可以使用十六进制字符的ASCII代码`\xx`在哪里转义特殊字符`xx`。通过这种方式，任何字符都可以在名称值中使用，甚至可以引用自己。该`\01`前缀可以在全局值可用于压制截断。
2. 未命名的值表示为带有前缀的无符号数值。例如%12，@2，%44。
3. 常量，将在后面的关于常量的部分进行描述。

Tuyin要求值以一个前缀开始有两个原因：

- 编译器不需要担心值的名称会和保留字（reserved words）冲突，保留字（reserved word）集可以在未来扩展的时候不会出现惩罚（penalty，不会发生冲突）。
- 非命名的identifier允许编译器快速找出一个临时变量且不会造成符号表冲突。

Tuyin中的保留字与其他语言的保留字非常相似。有相应的关键字对应着不同的操作码有(add, bitcast, ret, etc…)，原始类型名(void, i32,etc…)和其他。这些保留字不会与变量名冲突，因为他们之中没有一个是以前缀(% or @)开头的。

这里有一个表示用8乘上一个整型变量`%x`的Tuyin代码例子：

```csharp
#The easy way:　　　　
%result = %x * 8
%result = %X << 3

#And the hard way:　　　　
%0 = %X + %X           // yields {i32}:%0
%1 = %0 + %0           // yields {i32}:%1
%result = %1 + %1
```

用8乘上`%x`的最后的方式说明了Tuyin的几个重要的词法特点：

1. 注解是以 `//` 分隔且直到当前行的结尾
2. 当计算的结果不能被赋值的一个具名值的时候，非命名临时变量被创建
3. 非具名临时变量是按顺序编号的（使用一个递增计数器，从0开始）。注意整个基本块都被包含在这种编号方法中。例如，如果一个基本块的入口没有被给予一个标签名，那么它就会获得一个编号0。

它也表明了一个在这个文档我们应该遵循的约定。当演示指令的时候，我们应该使一个定义了被创建的值的类型和名称的注释紧跟这条指令后面。

## <span id="module_class_">模块结构

Tuyin程序由Module’s组成，每个程序模块都是输入程序的翻译单元。每个模块由函数，全局变量和符号表条目组成。模块可以与[Tuyin IR 链接器](http://www.iuiujs.com/reference/linker)组合在一起，链接器将解析前向声明后合并全局定义(如[函数](#func_class_))，并输出目标。

以下是`hello world`模块的示例：

```csharp
// Declare the string constant as a global constant.
@str = "hello world\0A\00";

// External declaration of the puts function from file path
import "../fileName.ti";

// Definition of second set
public subset @second
  // Call puts(from import external) function to write out the string to stdout.
  @puts <- @str                  !foo

// Definition of main set
subset @main                    !0
  match input.read(4) with
  | 0       -> 3,       !0
  | 1       -> 8
  | 2       -> second
  | _       -> %1 + 1

// metadata
!0 = !{i32 42, null, !"string"}
!foo = !{!0}
```

这个例子由一个全局常量`@str`，一个`@puts`函数的外部引用，`@main`和`@second`的[函数](#func_class_)定义和一个具名[元数据](#metadata_class_)`foo`组成。

一般情况下，一个模块由全局值（函数和全局变量都是全局值）的列表组成，全局值通过存储单元的指针表示（在这种情况下，一个指针指向字符数组，一个指针指向一个函数）并具有以下的链接类型之一。

## 输出目标

Tuyin IR 会根据编译环境提供的SDK不同输出不同目标，目前支持:

- 支持`wasi`接口的`amd64`执行环境。
- 基于`wasm`的标PE文件。
- 转译为`C`,`C#`,`Java`,`Javascript`和`Python`等流行语言输出。

对于出`amd64`的应用程序时，Tuyin IR输出中的函数目标支持外部引用，支持*gdb*调试在**ELF**的基础上设计了一个**超集**来给独立的调试器(详见[Tuyin IR 调试器](http://www.iuiujs.com/reference/debugger))的高级特性提供支持。

### <span id="link_class_">链接类型

在Tuyin IR程序中，所有常量和函数都具有以下类型的链接之一：

- **private**: *private*链接的内容只能由当前模块中的对象直接访问，在源码文件中其访问符会设置为*private*，在不支持访问级别的语言(如*Javascript*)输出目标中编译器会根据其特性进行适当的调整。
- **internal**: 与*private*相似，但该值在*object file*表现为*local symbol* (STB_LOCAL in the case of ELF) . 这对应于C中的**static**的关键字的概念。
- **external**: 如果上述标识符都没被使用，那么该全局变量的是外部可见的，这意味着它可以参与链接，可用于解析外部符号引用。

::: tip
使用*private*链接类型，在必要情况下可能会进行其[标识符](#token_class_)的重命名。因为这个符号是对当前模块私有的，所以我们可以认为它是安全的。这并不会在*object file*的任何*symbol table*中展示出来。
:::

### <span id="visual_class_">可见性模式

在Tuyin IR程序中，所有常量和函数具有以下的可见性模式之一：

- **“default” – Default style**：在那些使用*ELF object file*格式的平台，默认可见性意味着声明对于其他模块是可见的，，并且在可共享库，意味着这个声明的实体是可被覆盖的。在Darwin平台，默认可见性意味着声明对于其他模块是可见的。默认可见性与在链接类型中的*external linkage*是一致的。
- **“hidden” – Hidden style**：一个对象的带有*hidden*可见性的两个声明，如果它们是处于一个相同的可共享单元（*shared object*），那么它们会被引用到一个相同的对象。通常来说，*hidden*可见性表明符号不会被放置到动态符号表，所以其他模块（可执行程序或共享库）不可以直接引用这个符号。
- **“protected” – Protected style**：在ELF中，*protected*可见性表明符号会被放置到动态符号表，但在特定模块中的这些引用会绑定到一个本地的符号。所以这个符号不能被其他模块覆盖。

::: tip
带*internal*或**private*链接的符号必须具有*default*可见性。
:::

### <span id="runtime_lock_">运行时抢占说明符
在Tuyin IR中，全局变量，函数和别名可以具有可选的运行时抢占说明符。如果未明确给出抢占说明符，则假定符号为*dso_preemptable*。

- **dso_preemptable**：指示在运行时可以用链接单元外部的符号替换函数或变量。
- **dso_local**：编译器可以假设标记为的函数或变量dso_local将解析为同一链接单元内的符号。即使定义不在此编译单元内，也将生成直接访问。

## <span id="io_class_">标准I/O

Tuyin IR中内置了一个标准IO接口，用于读取/写入数据到不同目标段，其大小需要在定义时给出一个[常量表达式](#const_class_)。

示例：
```csharp
mem = [1024]
```

上述示例中**1024**为memory大小，这与C中的alloc分配空间相同，同时该大小声明的单位为[byte](#byte_tip_)，并可以用以下方式进行写入和读取。

```csharp
// declare output memory
mem = [1024]

match input.read(4) with
| 1.1       -> mem <- $1 + 1 // f32
| 1         -> mem <- $1 + 1 // i32
| _

match mem.peek(4) with
| ...
```

::: tip
标准I/O接口可以参阅[附录](#io_cmd_)。
:::

## 执行内存

在Tuyin IR中一个非常重要的概念就是**堆栈**的使用，它与通常的编程语言有很大区别，在流行通用编程中由于日益提高的项目复杂性让内存概念有两个大块`堆`和`栈`，其中`堆`内存的管理机制相对复杂，有一套专用的分配策略以防止大量小内存碎片出现，同时加快查找可用部分，进而不同的垃圾回收机制（如GC或手动管理）相序出现，先不提手动管理，只说现代GC技术也得到了不小的突破，我们在托管内存中几乎感受不到其回收时的停顿。

但是在Tuyin IR中我们为简化模型概念并进一步提升易用性加快运行性能，我们弃用**全局引用**从而避免其带来的[负作用](#poison_class_)，让我们可以完全获得在往常在`堆`内使用的**内存块**的生命周期，同时在对递归引用`堆`内数据做了特殊处理，让我们有效的安排数据前后位置来达到[堆栈转换](#nogc_tip_)，继而Tuyin IR中使用`堆`内存在使用策略上与计算`栈`几近相同，如下所示:

<div align=center>
<img src="../images/memory_layout_use.svg"/>
</div>

当Tuyin IR程序进入`函数`(如上图**递归操作**)时都会根据`栈`当前位置进行对内存的访问或申请，每当一个函数退出时（如上图**判断函数结束**）将直接把`栈`当前索引设置为函数返回的有效部分。

示例：

```csharp
// 在尾递归中,假设在第一次进入loop时栈地址为0
// 在x小于等于100时，只保留参数值，返回地址为0，后续有效长度为0 + 32 * 1
// 在x大于100时返回一块新申请的内存,返回地址为0,后续有效数据长度0 + 32 * 100
subset loop // memory i32 * 100
    input.peek(4) + 1 > 100 ? [100 * 8] : input <- input.pop() + 1 loop

// 在线性函数中，假设在第一次进入line时栈地址为0
// 在第一个loop 5的调用后，当前栈地址为0,后续有效数据长度0 + 32 * 100
// 在第二个loop 88的调用后，当前栈地址为0 + 32 * 100,后续有效数据长度0 + 32 * 100
// 在最终的1压入栈时，继续向后偏移32，最终栈位置为，(0 + 32 * 100) * 2 + 32
// 而(...)中使用了该3个参数，所以我们将有效数据长度设置为，当前栈长度（(0 + 32 * 100) * 2 + 32）-函数进入时地址(0)
subset line 
    (loop，loop, 1)

```

::: tip
上述表示了Tuyin IR程序使用了内存的基本策略，但是在实际应用过程中，包含大量无效或可优化数据（不参与最终计算结果或没有任何引用）将被优化器剔除，详情[Tuyin IR 优化器](http://www.iuiujs.com/reference/optimizer)。
:::

### <span id="memory_layout_">数据布局

Tuyin IR中外部数据通常都是由输入流或常量中匹配而来，并以指定长度进行读取，如下：

```csharp
match input.read(8) with
| 1.1       -> ... // f64
| 1         -> ... // i64
| "str1"    -> ... // str(mem block)
| _
```

::: tip 
其中**1.1**和**1**都是为常量数据，它们会转换成对应[byte](#byte_tip_)流在编译阶段中的[最大合并](#compiler_merge_)分析中进行分析使用。
:::

### 浮点环境

默认的Tuyin IR浮点环境假定浮点指令没有副作用。结果假设为舍入到舍入模式。此环境中不保留浮点异常状态。因此，在这些示例中，不会尝试创建或保留无效操作（SNaN）或零除异常。

这种无异常假设的好处是可以自由地推测浮点运算，而不需要对浮点模型进行任何其他快速数学松弛。

需要与此不同的行为的代码应使用 Constrained Floating-Point Intrinsics

#### 快速数学标志

Tuyin IR浮点运算（fadd，fsub，fmul，fdiv，frem，fcmp）和call可以使用以下标志来启用其他不安全的浮点转换。

- nnan: 没有NaNs - 允许优化假设参数和结果不是NaN。需要进行这样的优化才能在NaN上保留已定义的行为，但结果的值未定义。
- ninf: 无Infs – 允许优化假设参数和结果不是+/-Inf。需要进行这样的优化才能在+/-Inf上保留已定义的行为，但结果的值未定义。
- nsz: 无签名零 – 允许优化将零参数或结果的符号视为无关紧要。
- arcp: 允许互惠(Reciprocal) – 允许优化使用参数的倒数而不是执行除法。
- contract: 允许浮点收缩（例如，融合乘法，然后将加法融合为融合乘加）。
- afn: 近似函数 – 允许用近似计算代替函数（sin，log，sqrt等）。有关可应用于Tuyin的内在数学函数的位置，请参阅浮点内在定义。
- reassoc: 允许重新关联转换为浮点指令。这可能会显着改变浮点结果。
- fast: 这个标志暗示其他所有的。

示例：

```csharp
match input.read(8) with
| 1.1 * input.read(4), arcp, nsz -> ...
| _
```

## <span id="func_class_">函数

在Tuyin IR中函数是非常重要的概念之一，可以用**func**来定义，与传统函数不同的是，它将**实参列表**用[输入流](#io_class_)替代。

其每一个函数都包含以下定义参数:

- 可选的[链接标识(linkage)](#link_class_)
- 可选的[可见性样式(visibility)](#visual_class_)
- 函数名(func_name)
- 可选的[函数元数据(metadata)](#metadata_class_)
- 可选的空间地址(addr_space)，可以让自己在指定地址存储，如果未给出显式地址空间，则使用编译器所提供的默认策略，如果给出该**unnamed_addr**属性，则知道该地址不重要，并且可以合并两个相同的函数，如果给出该**local_unnamed_addr**属性，则该地址在模块内是不明显的。
- 可选的对齐长度(align N) ，可以为函数指定明确的对齐方式，且**N**应为2的幂。如果不存在，或者如果对齐方式设置为零，则函数的对齐由目标机设置为编译器所提供的默认策略。

示例：

```csharp
[linkage] [visibility] func <func_name> [metadata]
       [(unnamed_addr|local_unnamed_addr)] [addr_space] [align N] 
       { ... }
```

一个函数定义包含一个上述的基本参数列表和形成该函数的**CFG**（控制流图）。每个**CFG**可以有选择地以一个标签(地址偏移量)开始，包含指令列表，并以终止指令(如`branch`或`ret`等,控制流详见[指令集](#instructions_))结束。如果未提供显式(大部分由用户自定义)标签，则自动生成由编译器代管隐式(未公开且不可外部调用)标签，使用编号计数从0开始以此类推，例如，**prefix_0**至**prefix_N**。

::: tip
在分析**CFG**后自己将得到其后续工作需要用到的隐藏参数，如下：
- 返回类型
- 计算堆栈变化
- 函数大小
:::

## 别名/签名

在Tuyin IR程序中，别名不会创建任何新数据，但它是外部(如其他[模块结构](#module_class_))指向具体[函数](#func_class_)地址的通用且唯一形式。

**签名**相当于别名的*强引用形式*，可以用于函数、常量表达式或类型，别名可能具有[链接类型](#link_class_)和[可见性样式](#visual_class_)，当加载多个模块时别名可能会产生引用冲突，这个时候可以使用签名形式进行指定别名使用，而进行签名的引用无法通过JIT方式使用。

示例：

```csharp
<alias_name> = <moudle_name> [linkage] [visibility] [(unnamed_addr|local_unnamed_addr)] alias <name> 
            // 当使用dll_refer_guid时，别名将提升为签名
            [dll_refer_guid]
```

由于别名只是第二个名称，因此有些限制适用，其中一些只能在生成对象文件时进行检查：

- 定义别名的表达式必须在汇编时可计算。因为它只是一个名字，不能使用重定位。
- 别名被认为是强签名，是唯一的，因为中间别名被覆盖的可能性无法在对象文件中表示。
- 别名的使用会产生冲突，此时会造成编译无法通过，需要用户修改或指定别名的引用。
- **dll_refer_guid** 通常由编译器自动管理，它相当于一个模块的Guid。

::: tip
- `linkage`需要指定**private**,**internal**或**external**，若未填写的话则默认设置成**private**。
- 不是**unnamed_addr**的别名需要保证具有与别名表达式具有相同的地址。如**local_unnamed_addr**需要不可缺省。
- `dll_refer_guid`通常由将由编译器生成，亦可以通过声明[属性组](#attribute_class_)的方式来指定。
:::

## <span id="metadata_class_">元数据

命名的元数据是元数据的集合。元数据节点(但不是元数据字符串)是命名元数据的唯一有效操作数，它常被用来外部工具得到[退化(degenerative)](#degenerative_tip_)前的源文件数据（如函数命名等）所使用。

命名的元数据被表示为一个带有元数据前缀的字符串。元数据名称的规则与[标识符](#token_class_)相同，但引用的名称不被允许。`\\xx`类型转义仍然有效，它允许任何字符成为名称的一部分。

示例：

```csharp
// Some unnamed metadata nodes, which are referenced by the named metadata.
!0 = !{!"zero"}
!1 = !{!"one"}
!2 = !{!"two"}
// A named metadata.
!name = !{!0, !1, !2}
```

## <span id="attribute_class_">属性组

属性组是由IR内的对象引用的一组属性。它们对于保持[.ti](#ti_tip_)文件可读性很重要，因为许多函数将使用同一组属性。在与单个.c(或其他源码文件)文件相对应的[.ti](#ti_tip_)文件的[退化(degenerative)](#degenerative_tip_)情况下，属性组将用于构建描述该文件的原始信息等重要的命令行标志。

一个属性组是一个模块级别(这与[函数](#func_class_)是相同级别)的对象。可以使用属性组的ID（例如"**#37**"）来使用属性组给模块对象赋于属性，且当一个对象使用来自于不同ID的属性组时它们会被自动合并。

下面是一个应该总是内联的函数的属性组的示例，其堆栈对齐方式为4，不应使用SSE指令：

```csharp
// Target-independent attributes:
attributes #0 = { alwaysinline alignstack=4 }

// Target-dependent attributes:
attributes #1 = { "no-sse" }

// Function @f has attributes: alwaysinline, alignstack=4, and "no-sse".
define void @f() #0 #1 { ... }
```

::: tip
属性组详细命令行可以参阅[附录](#prototype_cmd_)。
:::

## 类型系统

Tuyin IR类型系统是中间表示的最重要的特征之一，在编译过程中类型化使得很多对内存引用和静态信息可以在不必在运行期额外声明，从来达到优化的目的。强大的类型系统使读取生成的代码变得更加容易，并且支持新的分析和转换。

#### void类型

概述：void类型不代表任何值并且没有大小。

文法： void

#### 整数类型

概述：整数类型是一个非常简单的类型，它简单地为所需的整数类型指定一个任意的位宽。可以指定从1位到223-1（约8百万）的任何位宽。

文法：**iN**

整数将占据的位数由该**N**值指定。

示例：
- **i1** 一个单位整数。
- **i32** 一个32位整数。
- **i1942652** 一个超过100万位的大整数。

#### 浮点类型

概述：有理数中某特定函数的数的数字表示，在计算机中用以近似表示任意某个实数。具体的说，这个实数由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂。

文法：**fX.Y|type**

整数将占据的位数由该**X**值指定，尾数位数将由**Y**值指定。

示例：
- **f1.1** 一个由单位整数和单位尾数组合成的浮点数。
- **f16.16** 一个由16位整数，16位尾数组合成的浮点数。
- **f1942652.1** 一个超过100万位的大整数和单位尾数组合成的浮点数。
- **half** 16位浮点值
- **float** 32位浮点值
- **double** 64位浮点值
- **fp128** 128位浮点值(两个64位)

::: tip
half，float，double和fp128的二进制格式分别对应于binary16，binary32，binary64和binary128的IEEE-754-2008规范。
:::

#### 指针类型

概述： 指针类型用于指定内存位置。指针通常用于引用内存中的对象。

指针类型可能有一个可选的地址空间属性，用于定义指向对象所在的编号地址空间。默认地址空间是数字零。非零地址空间的语义是特定于目标的。

文法：**type\***

示例：

- **i32\*** i32值的指针。
- **(i32, float)\*** (i32, float)值的指针。
- **i32 addr_space(5)\*** i32值的指针，指针以5个字节递增/减。
- **[128] addr_space(4)\*** 4个的i32值数组的指针。

::: tip
Tuyin IR中由于统计完整的调用层次来获得申请的内存的[生命周期](#life_tip_)，所以不允许指向[函数](#func_class_)的指针，所以在Tuyin IR中无法实现类似委托的调用，也不允许指向标签（label*）的指针。
:::

#### 结构体类型

在Tuyin IR中，`literal`结构体类型，它通常用以下方式声明：

概述：矢量类型是表示元素矢量的简单派生类型。当使用单个指令（SIMD）并行操作多个原始数据时，使用矢量类型。矢量类型需要大小（元素数量）和基础原始数据类型。矢量类型被认为是第一类。

示例：

```csharp
// Declare the type (i32, i1) varibale.
first = (1, true)                       // type (i32, i1)

// Declare the type (i32, i1, i1) varibale.
second = (1, true, true)                // type (i32, i1, i1)
```

而在具体相同返回值时，如`subset`内，`first`和`second`的隐式类型自动归并和继承:

```csharp
subset type // Declare first's type subset
    match read(1) with
    | true  -> first = (1, true)        // type (i32, i1)
    | false -> second = (1, true, true) // type (first, i1) same as second : first
```

::: tip
在Tuyin IR中只有`literal`类型是唯一的。
:::

#### 函数类型

概述：函数类型可以被认为是函数签名。它由一个返回类型和一个形式参数类型列表组成。函数类型的返回类型是void类型或第一类类型–标签和元数据类型除外。

文法：\<returntype> (\<parameter list>)

…其中<parameter list>是逗号分隔的类型说明符列表。可选地，参数列表可以包括类型…，该类型指示该函数采用可变数目的参数。变量参数函数可以通过处理内部函数的变量参数来访问它们的参数。\<returntype>是除标签和元数据之外的任何类型。

#### 隐式化

在Tuyin IR中类型化非必要时总是总是以隐式的方式获取，又编译器自动管理，但同时在必要时也可以由用户指定。

示例：

```csharp
@first = 1          // i32
@second = i64 1     // i64
```

## <span id="const_class_">常量

Tuyin IR中的常量通常由简单常量和复杂常量构成，同时也支持使用常量表达式进行声明。

#### 简单常量

- **布尔常量**: 两个字符串**true**和**false**都是该i1类型的有效常量。

- **整型常量**: 标准整数（如4）是整数类型的常量。负数可能与整数类型一起使用。
- **浮点常量**: 浮点常量使用标准十进制表示法（例如123.421），指数表示法（例如1.23421e+2）或更精确的十六进制表示法。汇编器需要浮点常量的精确十进制值。例如，汇编程序接受1.25，但拒绝1.3，因为1.3是二进制中的重复小数。浮点常量必须具有浮点类型。
- **空指针常量**: 标识符**null**被识别为空指针常量，并且必须是指针类型。

常量的一个非直观符号是浮点常量的十六进制形式。例如，形式为double 0x432ff973cafa8000等同于double 4.5e+15。唯一需要十六进制浮点常量（以及它们由反汇编程序生成的唯一时间）是必须发出浮点常量但不能用合理数目的十进制浮点数表示的浮点常量数字。例如，NaN's，infinities和其他特殊值以IEEE十六进制格式表示，因此汇编和反汇编不会导致常量中的任何位发生更改。

当使用十六进制形式时，half，float和double类型的常量使用上面显示的16位数字形式表示（与IEEE754表示符合double）;
然而，half和float值必须分别精确表示为IEEE 754的半精度和单精度。十六进制格式总是用于长双，并有三种形式的长双。x86使用的80位格式表示0xK后跟20个十六进制数字。PowerPC使用的128位格式（两个相邻的双精度）0xM由32个十六进制数字表示。IEEE 128位格式0xL由32个十六进制数字表示。长双打只有在你的目标上的长双重格式匹配时才有效。IEEE16位格式（半精度）由表示0xH后跟4个十六进制数字。所有的十六进制格式都是big-endian（左边的符号位）。

#### 复杂常量（Complex Constants）

复杂常量是简单常量和较小复常量的（可能递归）组合。

- **结构常数**： 结构常量用类似于结构类型定义的符号表示（逗号分隔的元素列表，用大括号（{}）括起来）。例如：“{ 4, 17.0, @G }，其中“@G被声明为“@G = external global i32。结构常量必须具有结构类型，并且元素的数量和类型必须与该类型指定的类型匹配。

- **数组常量**： 数组常量用类似于数组类型定义的符号表示（逗号分隔的元素列表，用方括号（[]）括起来）。例如：[ 42, 11, 74 ]。数组常量必须具有数组类型，并且元素的数量和类型必须与该类型指定的数量和类型相匹配。作为一种特殊情况，字符数组常量也可以用前缀表示为双引号字符串。例如：“c"Hello World\0A\00"。
- **零初始化**： 字符串zeroinitializer可用于将零值初始化为任何类型的零，包括标量和聚合类型。这通常用于避免必须打印大型零初始化器（例如，用于大型数组），并且始终完全等同于使用显式零初始化器。
- **元数据节点**： 元数据节点是一个没有类型的常量元组。例如：!{!0, !{!2, !0}, !"test"}。元数据可以引用常量值，例如：!{!0, 0, @global, @function, !"str"}。与其他类型化的常量不同，它们被解释为指令流的一部分，元数据是附加附加信息的地方，例如调试信息。

#### 常量表达式



#### 全局常量和函数的地址

常量和函数的地址总是隐式有效（链接时间）的常量。当使用全局标识符并且总是有指针类型时，这些常量被明确引用。例如，以下是合法的Tuyin IR文件：

```csharp
@X = global 17
@Y = global 42
@Z = global [64] [ @X, @Y ]
```

#### <span id="poison_class_">负作用/毒药值（Poison Values）

毒药（Poison）值与undef值相似，但它们也表示这样的事实，即不能引起副作用的指令或常量表达式已经检测到导致未定义行为的条件。

目前在IR中无法表示毒物值;
它们只存在于某些操作的调用，如带有nsw标志的add操作。

#### 基本块的地址
文法： **blockaddress(@function, %block)**

在**blockaddress**常数计算在指定函数指定的基本块的地址，并总是有一个i8*类型。取出输入块的地址是非法的。

当用作**indirectbr**指令的操作指令时，或者用于与空值进行比较时，该值仅具有已定义的行为。标签地址之间的指针相等测试会导致未定义的行为
–
但是，再次，与null进行比较是可以的，并且没有标签等于空指针。只要这些位未被检查，这可以作为不透明的指针大小值传递。**ptrtoint**只要原始值在**indirectbr**指令之前重新构成，就允许和计算这些值。

最后，有些目标可能会在使用该值作为内联程序集的操作数时提供定义的语义，但这是目标特定的。

## 附录

### 名词

- <span id="byte_tip_">**byte** 字节（Byte）是存储数据的基本单位。
- <span id="ti_tip_">**.ti** Tuyin IR 所使用的人类可读的中间输出的文件名后缀。
- <span id="degenerative_tip_">**退化(degenerative)** 当源码文件被编译成.ti文件时，此时.ti文件所包含信息不足以描述源文件内容，称其为退化。
- <span id="compiler_merge_">**最大合并** 编译分析阶段查找编译源底层相同部分，测试详见playground中的[最大合并](http://www.iuiujs.com/playground/maxmerge)。
- <span id="nogc_tip_">**堆栈转换** 待补充，测试详见playground中的[生命周期](http://www.iuiujs.com/playground/liferound)。
- <span id="life_tip_">**生命周期** 在Tuyin IR中主要指变量和内存块在调用堆栈中存活的周期。

### <span id="prototype_cmd_">属性组命令

- **no-sse** 在graph生成时，不进行线性合并操作，如果不标记时，abcde(或任意线性长度)在graph中表示为**x**，**x**是编译策略临时所分配，在最终阶段自动映射到目标平台指令。

#### <span id="instructions_">指令集

##### add

|名称|堆栈变化|操作数类型|控制流|说明|
|-----|--------|------------|-------|------------------------------------|
|add|-1|none|next|将两个值相加并将结果推送到计算堆栈上。|
|and|-1|none|next|计算两个值的按位"与"并将结果推送到计算堆栈上。|
|beg|-2|uint32|branch|如果两个值相等，则将控制转移到目标指令。|
|bge|-2|uint32|branch|如果第一个值大于或等于第二个值，则将控制转移到目标指令。|
|bgt|-2|uint32|branch| 如果第一个值大于第二个值，则将控制转移到目标指令。|
|ble|-2|uint32|branch| 如果第一个值小于或等于第二个值，则将控制转移到目标指令。|
|blt|-2|uint32|branch| 如果第一个值小于第二个值，则将控制转移到目标指令。|
|br|0|uint32|jump| 如果第一个值小于第二个值，则将控制转移到目标指令。|
|brfalse|-1|uint32|jump| 如果 value 为 false、空引用或零，则将控制转移到目标指令。|
|brtrue|-1|uint32|jump| 如果 value 为 true、非空或非零，则将控制转移到目标指令。|
|call|0|uint32|call| 调用方法 参数:调用方法传递的参数数量。|
|ceq|-1|none|next| 比较两个值。 如果这两个值相等，则将整数值 1 (int32) 推送到计算堆栈上；否则，将 0 (int32) 推送到计算堆栈上。|
|cgt|-1|none|next| 比较两个值。 如果第一个值大于第二个值，则将整数值 1 (int32) 推送到计算堆栈上；反之，将 0 (int32) 推送到计算堆栈上。|
|clt|-1|none|next| 比较两个值。 如果第一个值小于第二个值，则将整数值 1 (int32) 推送到计算堆栈上；反之，将 0 (int32) 推送到计算堆栈上。|
|div|-1|none|next| 将两个值相除并将结果作为浮点 Number 推送到计算堆栈上。|
|ldstr|1|string|next| 将字符串推送到计算堆栈上。|
|ldarg|1|uint32|next| 将索引 x 参数推送到计算堆栈上。|
|ldarg.0|1|none|next| 将索引 0 参数推送到计算堆栈上。|
|ldarg.1|1|none|next| 将索引 1 参数推送到计算堆栈上。|
|ldarg.2|1|none|next| 将索引 2 参数推送到计算堆栈上。|
|ldarg.3|1|none|next| 将索引 3 参数推送到计算堆栈上。|
|ldloc|1|uint32|next| 将索引 x 区域变量推送到计算堆栈上。|
|ldloc.0|1|none|next| 将索引 0 区域变量推送到计算堆栈上。|
|ldloc.1|1|none|next| 将索引 1 区域变量推送到计算堆栈上。|
|ldloc.2|1|none|next| 将索引 2 区域变量推送到计算堆栈上。|
|ldloc.3|1|none|next| 将索引 3 区域变量推送到计算堆栈上。|
|ldc.r4|1|float32|next| 将 x 作为 Float32 推送到计算堆栈上。|
|ldc.r8|1|float64|next| 将 x 作为 Float64 推送到计算堆栈上。|
|ldc.l|1|int64|next| 将 x 作为 Int64 推送到计算堆栈上。|
|ldc|1|int32|next| 将 x 作为 Int32 推送到计算堆栈上。|
|ldc.m1|1|int32|next| 将Int32类型 -1 作为 Number 推送到计算堆栈上。|
|ldc.0|1|int32|next| 将Int32类型 -1 作为 Number 推送到计算堆栈上。|
|ldc.1|1|int32|next| 将Int32类型 -1 作为 Number 推送到计算堆栈上。|
|ldc.2|1|int32|next| 将Int32类型 -1 作为 Number 推送到计算堆栈上。|
|ldc.3|1|int32|next| 将Int32类型 -1 作为 Number 推送到计算堆栈上。|
|ldc.4|1|int32|next| 将Int32类型 -1 作为 Number 推送到计算堆栈上。|
|ldc.5|1|int32|next| 将Int32类型 -1 作为 Number 推送到计算堆栈上。|
|ldc.6|1|int32|next| 将Int32类型 -1 作为 Number 推送到计算堆栈上。|
|ldc.7|1|int32|next| 将Int32类型 -1 作为 Number 推送到计算堆栈上。|
|ldc.8|1|int32|next| 将Int32类型 -1 作为 Number 推送到计算堆栈上。|
|ldc.9|1|int32|next| 将Int32类型 -1 作为 Number 推送到计算堆栈上。|
|mul|-1|none|next| 将两个值相乘并将结果推送到计算堆栈上。|
|neg|0|none|next| 对一个值执行求反并将结果推送到计算堆栈上。|
|nop|0|none|next| 如果修补操作码，则填充空间。 尽管可能消耗处理周期，但未执行任何有意义的操作。|
|not|0|none|next| 计算堆栈顶部整数值的按位求补并将结果作为相同的类型推送到计算堆栈上。|
|or|-1|none|next| 计算位于堆栈顶部的两个整数值的按位求补并将结果推送到计算堆栈上。|
|peek|1|none|next| 复制堆栈顶层值并推入堆栈。|
|pop|-1|none|next| 移除当前位于计算堆栈顶部的值。|
|rem|-1|none|next| 将两个值相除并将余数推送到计算堆栈上。|
|ret|0|none|next| 从当前方法返回，并将返回值（如果存在）从调用方的计算堆栈推送到被调用方的计算堆栈上。|
|shl|-1|none|next| 将整数值左移（用零填充）指定的位数，并将结果推送到计算堆栈上。|
|shr|-1|none|next| 将整数值右移（保留符号）指定的位数，并将结果推送到计算堆栈上。|
|sub|-1|none|next| 用计算堆栈中的值赋值给指定索引处的区域变量。|
|throw|-1|none|throw| 引发当前位于计算堆栈上的异常对象。|
|xor|-1|none|next| 计算位于计算堆栈顶部的两个值的按位异或，并且将结果推送到计算堆栈上。|
|breakpoint|0|none|break| 暂停程序并，通知（如果被调试器捕获进程）当前位于计算堆栈上地址。|

#### 额外操作函数

